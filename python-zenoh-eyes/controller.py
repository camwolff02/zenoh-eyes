#!/usr/bin/env python3
import argparse, curses, json, time
import flatbuffers
import zenoh
from zenoh import Config
from electric_eyes import EyeCommand  # generated by flatc (Python)

# KEYBINDINGS
QUIT = {ord('q'), ord('Q')}
BLINK = {ord('b'), ord('B')}
RESET = {ord('r'), ord('R')}
DECRIMENT = {curses.KEY_DOWN, ord('-'), ord('j')}
INCREMENT = {curses.KEY_UP, ord('+'), ord('='), ord('k')}
MENU_LEFT = {curses.KEY_RIGHT, ord('l')}
MENU_RIGHT = {curses.KEY_LEFT, ord('h')}

def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def build_eye_cmd(lr, ud, sep, blink):
    b = flatbuffers.Builder(0)
    EyeCommand.EyeCommandStart(b)
    EyeCommand.EyeCommandAddLookLr(b, int(lr))
    EyeCommand.EyeCommandAddLookUd(b, int(ud))
    EyeCommand.EyeCommandAddEyeSep(b, int(sep))
    EyeCommand.EyeCommandAddBlink(b, bool(blink))
    eye = EyeCommand.EyeCommandEnd(b)
    b.Finish(eye)
    return b.Output()

def parse_args():
    p = argparse.ArgumentParser(description="Electric Eyes TUI (Zenoh + FlatBuffers)")
    # Limits
    p.add_argument("--lr-min", type=int, default=-90)
    p.add_argument("--lr-max", type=int, default=90)
    p.add_argument("--ud-min", type=int, default=-90)
    p.add_argument("--ud-max", type=int, default=90)
    p.add_argument("--sep-min", type=int, default=0)
    p.add_argument("--sep-max", type=int, default=90)
    # Steps
    p.add_argument("--step-lr", type=int, default=2)
    p.add_argument("--step-ud", type=int, default=2)
    p.add_argument("--step-sep", type=int, default=2)
    # Initial values
    p.add_argument("--lr0", type=int, default=0)
    p.add_argument("--ud0", type=int, default=0)
    p.add_argument("--sep0", type=int, default=90)
    # Zenoh
    p.add_argument("--keyexpr", default="robot/eye_command")
    p.add_argument("--endpoint", action="append", help='Zenoh endpoint, e.g. tcp/192.168.68.136:7447 (repeatable)')
    p.add_argument("--rate-hz", type=float, default=10.0, help="publish rate (Hz)")
    return p.parse_args()

def tui(stdscr, args):
    curses.curs_set(0)
    stdscr.nodelay(True)
    stdscr.timeout(50)  # getch() every 50ms

    # Zenoh session
    conf = Config()
    if args.endpoint:
        conf.insert_json5("connect/endpoints", json.dumps(args.endpoint))
    session = zenoh.open(conf)
    pub = session.declare_publisher(args.keyexpr)

    # State
    lr = clamp(args.lr0, args.lr_min, args.lr_max)
    ud = clamp(args.ud0, args.ud_min, args.ud_max)
    sep = clamp(args.sep0, args.sep_min, args.sep_max)
    selected = 0  # 0:LR, 1:UD, 2:SEP
    blink_once = False

    step_map = {0: args.step_lr, 1: args.step_ud, 2: args.step_sep}
    limits = {0: (args.lr_min, args.lr_max), 1: (args.ud_min, args.ud_max), 2: (args.sep_min, args.sep_max)}

    interval = 1.0 / max(1e-6, args.rate_hz)
    next_pub = 0.0

    def publish(force_blink=False):
        nonlocal blink_once
        payload = build_eye_cmd(lr, ud, sep, blink_once or force_blink)
        pub.put(payload)
        # blink is one-shot
        blink_once = False

    # first publish
    publish()

    try:
        while True:
            now = time.time()

            # input
            ch = stdscr.getch()
            if ch != -1:
                if ch in QUIT:
                    break
                elif ch in {ord('1'),}:
                    selected = 0
                elif ch in {ord('2'),}:
                    selected = 1
                elif ch in {ord('3'),}:
                    selected = 2
                elif ch in BLINK:
                    blink_once = True
                    publish()  # send immediately
                    next_pub = now + interval
                elif ch in RESET:
                    lr, ud, sep = 0, 0, limits[2][1]  # center + open
                elif ch in DECRIMENT:
                    # decrement selected axis
                    if selected == 0:
                        lr = clamp(lr - step_map[0], *limits[0])
                    elif selected == 1:
                        ud = clamp(ud - step_map[1], *limits[1])
                    else:
                        sep = clamp(sep - step_map[2], *limits[2])
                elif ch in INCREMENT:
                    # increment selected axis
                    if selected == 0:
                        lr = clamp(lr + step_map[0], *limits[0])
                    elif selected == 1:
                        ud = clamp(ud + step_map[1], *limits[1])
                    else:
                        sep = clamp(sep + step_map[2], *limits[2])
                elif ch in MENU_RIGHT:
                    selected = (selected - 1) % 3
                elif ch in MENU_LEFT:
                    selected = (selected + 1) % 3

            # periodic publish
            if now >= next_pub:
                publish()
                next_pub = now + interval

            # draw
            stdscr.erase()
            stdscr.addstr(0, 0, "Electric Eyes TUI â€” arrows +/- adjust, 1/2/3 axis, b blink, r reset, q quit")
            stdscr.addstr(1, 0, f"Keyexpr: {args.keyexpr}")
            ep_str = ", ".join(args.endpoint) if args.endpoint else "(discovery)"
            stdscr.addstr(2, 0, f"Endpoint(s): {ep_str}    Rate: {args.rate_hz:.1f} Hz")

            def tag(i, name):
                return f"[{name}]" if i == selected else f" {name} "

            stdscr.addstr(4, 0, f"Axis {tag(0,'LR')} {tag(1,'UD')} {tag(2,'SEP')}")
            stdscr.addstr(6, 0, f"LR: {lr:>4} deg   limits=({limits[0][0]},{limits[0][1]})   step={step_map[0]}")
            stdscr.addstr(7, 0, f"UD: {ud:>4} deg   limits=({limits[1][0]},{limits[1][1]})   step={step_map[1]}")
            stdscr.addstr(8, 0, f"SEP:{sep:>4} deg   limits=({limits[2][0]},{limits[2][1]})   step={step_map[2]}")
            stdscr.addstr(10, 0, f"Blink one-shot queued? {'YES' if blink_once else 'no'}")

            stdscr.refresh()
            time.sleep(0.01)
    finally:
        try:
            pub.close()
        except Exception:
            pass
        session.close()

def main():
    args = parse_args()
    curses.wrapper(tui, args)

if __name__ == "__main__":
    main()
